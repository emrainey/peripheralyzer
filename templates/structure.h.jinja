{%- if structure.usings is defined and structure.usings %}
{%- for using in structure.usings %}
{%- if using.comment %}
/// {{using.comment}}
{%- endif %}
using {{using.to}} = {{using.from}};
{%- endfor %}
{%- endif %}

/// {{structure.comment}}
struct __attribute__((packed)) {{structure.name}} final {
{% if structure.enums is defined and structure.enums -%}
{% for enum in structure.enums %}
{% include 'enum.h.jinja' -%}
{% endfor %}
{% endif -%}
{% if structure.structures is defined and structure.structures -%}
{% for structure in structure.structures -%}
{% include 'structure.h.jinja' -%}
{% endfor -%}
{% endif -%}
{% if structure.registers is defined and structure.registers -%}
{% for register in structure.registers -%}
{% include 'register.h.jinja' -%}
{% endfor -%}
{% endif -%}
{% if structure.members is defined %}
{% for member in structure.members -%}
{%- if member.comment is defined and member.comment %}
    /// {{member.comment}}
{%- endif -%}
{%- if member.name is defined and member.name %}
{%- if member.count > 1 %}
    {{member.type}} {{member.name}}[{{member.count}}]; // offset {{member.offset}}UL
{%- else %}
    {{member.type}} {{member.name}}; // offset {{member.offset}}UL
{%- endif %}
{%- else %}
    {{member.type}} : {{structure.default_depth}}; // offset {{member.offset}}UL
{%- endif %}
{%- endfor %}
{%- endif %}
};
// Ensure the structure is in standard layout format
static_assert(std::is_standard_layout<{{structure.name}}>::value, "Must be standard layout");
// Enusre the offsets are all correct
{% for member in structure.members -%}
{% if member.name is defined and member.name -%}
static_assert(offsetof({{structure.name}}, {{member.name}}) == {{member.offset}}UL, "Must be located at this offset");
{% endif -%}
{% endfor %}
// Ensure the sizeof the entire structure is correct.
static_assert(sizeof({{structure.name}}) == {{structure.sizeof}}UL, "Must be this exact size");

{% if structure.base_address is defined and structure.base_address %}
namespace address {
constexpr std::uintptr_t {{structure.name|snake_case}} = {{structure.base_address}};
} // namespace address
/// The constant pointer to the volatile structure which is a memory mapped register or peripheral.
{{structure.name}} volatile* const {{structure.name|snake_case}} = reinterpret_cast<{{structure.name}} volatile* const>(address::{{structure.name|snake_case}});
{% endif %}